/*************************************************************************** Class:  CageAuthor:  Greg King  Date:  October 21, 2004This class is intended to be the environment in which our virtual animals will live. Date			Modification10-21-2004	Main Coding10-22-2004	addAnimal, removeAnimal methods12-03-2004	Modified the moveAnimal and removeAnimal methods to fix bugs03-27-2006  Added resources (food) to the cage****************************************************************************/import java.util.ArrayList;public class Cage{	private int numXs;	private int numYs;	private Animal [][] animals;	private int[][] resources;	private int numAnimals;		/**	*	No argument constructor creates a 1x1 empty cage.	*/	public Cage()	{		numXs = 1;		numYs = 1;		animals = new Animal[1][1];		resources = new int[1][1];		numAnimals = 0;	}		/**	*	Constructor creates a rows x columns sized array.	*	@param rows  number of rows (y coordinates) in cage	*	@param cols	 number of columns (x coordinate) in cage	*/	public Cage(int cols, int rows)	{		numXs = cols;		numYs = rows;		animals = new Animal[rows][cols];		resources = new int[rows][cols];		for(int r=0; r<rows; r++)		{			for(int c=0; c<cols; c++)			{				resources[r][c] = (int)(Math.random()*100+1);			}		}		numAnimals = 0;	}		/**	*	Method returns the Animal at position x,y.  Returns	*	a null Animal reference if the position is empty or	*	does not exist.	*	@return  Animals at Position x,y or a null Animal if 	*			 no such Position exists or Position is empty	*/	public Animal animalAt(int x, int y)	{		if (x<0 || x>=numXs || y<0 || y>= numYs)			return null;		else				return animals[y][x];	}		/**	*	Returns the amount of available resources from a given	*	position in the cage.  	*	@param x column coordinate	*	@param y row coordinate	*	@return amount of resources available for "harvest"	*/	public int resourcesAt(int x, int y)	{		if (x<0 || x>=numXs || y<0 || y>= numYs)			return -1;		int res = resources[y][x];		if (res<1)			res = 1;		return res;	}		/**	*	Returns the amount of resources that can be taken by a given 	*	Animal, removing those resources	*	@param pos position to be "mined" for resources	*	@param max max resources this animal can "take"	*	@return amount of resources taken	*/	public int takeResources(Position pos, int max)	{		int x = pos.getX();		int y = pos.getY();		if (x<0 || x>=numXs || y<0 || y>= numYs)			return -1;		int res = resources[y][x];		if(res >= max)		{			resources[y][x] -= max;			return max;		} 		resources[y][x] = 0;		return res;	}		/**	*	Method returns true if Cage has no empty cells, false	*	if there empty cells remaining.	*	@return  true if Cage has no empty cells, false otherwise	*/	public boolean isFull()	{		if (numAnimals < numXs*numYs)			return false;		return true;	}		/**	*	Method returns a random empty Position in the Cage, or a	*	null Position if no empty Positions exist.	*	@return  a random empty position in the Cage	*/	public Position randomEmpty()	{		Position pos = new Position();		Position [] empties;		if (isFull())			return null;					int x, y;		do		{			x = (int)(Math.random()*numXs);			y = (int)(Math.random()*numYs);			pos = new Position(x,y);			if(animals[x][y] != null)			{				empties = emptyNeighbors(pos);				if(empties.length==0)					pos = null;				else					pos = empties[0];			}					}		while (pos == null);				return pos;	}			/**	*	Method removes the given animal from the Cage.	*	@param removeThis  the animal to be removed	*	If given animal is not actually in the Cage then	*	nothing is done.	*/	public void removeAnimal(Animal removeThis)	{		int x = removeThis.getPosition().getX();		int y = removeThis.getPosition().getY();		if(animals[y][x].getID() == removeThis.getID())		{			numAnimals--;			animals[y][x] = null;		}	}			/**	*	Method adds the given Animal to the location	*	at which the Animal thinks it exists.  If that location	*	is already full, then no animal will be added and a	*	false value will be returned.  Otherwise true is returned.	*	@param  addThis  Animal to be added to the Cage	*	@return true if animal was added, false if not	*/	public boolean addAnimal(Animal addThis)	{		int x = addThis.getPosition().getX();		int y = addThis.getPosition().getY();		if(animals[y][x] != null)		{			return false;		}		animals[y][x] = addThis;		numAnimals++;		return true;	}			/**	*	Returns true if the given Position is empty (null), false if	*	it is not empty or is outside the Cage	*	@param  positionToCheck  Position to be checked	*	@return  true if Position is empty, false otherwise	*/	public boolean isEmptyAt(Position positionToCheck)	{		int x = positionToCheck.getX();		int y = positionToCheck.getY();		if(x<0 || y<0 || x>=numXs || y>=numYs)			return false;		if(animals[y][x] != null)		{			return false;		}		return true;	}			/**	*	Method moves the Animal to a new position in the cage.	*	Removes the reference to the Animal at the old position.	*	@param old Animal's old position	*	@param anim Animal to be moved to new position	*/	public void moveAnimal(Position old, Animal anim)	{		int newX = anim.getPosition().getX();		int newY = anim.getPosition().getY();		animals[old.getY()][old.getX()] = null;		animals[newY][newX] = anim;	}		/**	*	Method returns an array of all of the empty positions	*	adjacent to the given position.  In other words it is 	*	given a position and returns an array consisting of 	*	all of the positions next to the given position which	*	are also empty.	*	@param pos position to be checked	*	@return  array of all the empty positions adjacent 	*		to given position, returns an empty array if	*		pos is not inside the cage	*/	public Position[] emptyNeighbors(Position pos)	{		Position north=null, south=null, east=null, west=null;		Position [] listOfEmpties=null;		int count = 0;		int x = pos.getX();		int y = pos.getY();				if(y-1>=0 && animals[y-1][x] == null)		{			count++;			north = new Position(x, y-1);		}		if(y+1<numYs && animals[y+1][x] == null)		{			count++;			south = new Position(x, y+1);		}		if(x-1>=0 && animals[y][x-1] == null)		{			count++;			west = new Position(x-1, y);		}		if(x+1<numXs && animals[y][x+1] == null)		{			count++;			east = new Position(x+1, y);		}		if(count>0)		{			int index = 0;			listOfEmpties = new Position[count];			if(north != null)			{				listOfEmpties[index] = north;				index++;			}			if(south != null)			{				listOfEmpties[index] = south;				index++;			}			if(west != null)			{				listOfEmpties[index] = west;				index++;			}			if(east != null)			{				listOfEmpties[index] = east;				index++;			}		}		else			listOfEmpties = new Position[0];		return listOfEmpties;				}		/**	*	Method returns an array of all of the non-empty positions	*	adjacent to the given position.  In other words it is 	*	given a position and returns an array consisting of 	*	all of the positions next to the given position which	*	contain some Animal.	*	@param pos position to be checked	*	@return  array of all the non-empty positions adjacent 	*		to given position, returns an empty array if	*		pos is not inside the cage	*/	public Position[] nonEmptyNeighbors(Position pos)	{		Position north=null, south=null, east=null, west=null;		Position [] listOfNonEmpties=null;		int count = 0;		int x = pos.getX();		int y = pos.getY();				if(y-1>=0 && animals[y-1][x] != null)		{			count++;			north = new Position(x, y-1);		}		if(y+1<numYs && animals[y+1][x] != null)		{			count++;			south = new Position(x, y+1);		}		if(x-1>=0 && animals[y][x-1] != null)		{			count++;			west = new Position(x-1, y);		}		if(x+1<numXs && animals[y][x+1] != null)		{			count++;			east = new Position(x+1, y);		}		if(count>0)		{			int index = 0;			listOfNonEmpties = new Position[count];			if(north != null)			{				listOfNonEmpties[index] = north;				index++;			}			if(south != null)			{				listOfNonEmpties[index] = south;				index++;			}			if(west != null)			{				listOfNonEmpties[index] = west;				index++;			}			if(east != null)			{				listOfNonEmpties[index] = east;				index++;			}		}		else			listOfNonEmpties = new Position[0];		return listOfNonEmpties;				}		/**	 * Empties the Cage of all Animals	 */	public void clearCage()	{		for(int r=0; r<numYs; r++)		{			for(int c=0; c<numXs; c++)			{				animals[r][c] = null;			}		}	}			/**	*	Method returns an array of all of the non-empty positions	*	adjacent to the given position.  In other words it is 	*	given a position and returns an array consisting of 	*	all of the positions next to the given position which	*	contain some Animal.  This version looks at all 8 neighboring	*   positions, not just North-South-East-West	*	@param pos position to be checked	*	@return  array of all the non-empty positions adjacent 	*		to given position, returns an empty array if	*		pos is not inside the cage	*/	public Position[] nonEmptyNeighborsBroad(Position pos)	{		Position north=null, south=null, east=null, west=null;		Position northWest=null, southWest=null, northEast=null, southEast=null;		Position [] listOfNonEmpties=null;		int count = 0;		int x = pos.getX();		int y = pos.getY();				if(y-1>=0 && animals[y-1][x] != null)		{			count++;			north = new Position(x, y-1);		}		if(y-1>=0 && x-1>=0 && animals[y-1][x-1] != null)		{			count++;			northWest = new Position(x-1,y-1);		}		if(y-1>=0 && x+1<numXs && animals[y-1][x+1] != null)		{			count++;			northEast = new Position(x+1,y-1);		}		if(y+1<numYs && animals[y+1][x] != null)		{			count++;			south = new Position(x, y+1);		}		if(y+1<numYs && x-1>=0 && animals[y+1][x-1] != null)		{			count++;			southWest = new Position(x-1,y+1);		}		if(y+1<numYs && x+1<numXs && animals[y+1][x+1] != null)		{			count++;			southEast = new Position(x+1,y+1);		}		if(x-1>=0 && animals[y][x-1] != null)		{			count++;			west = new Position(x-1, y);		}		if(x+1<numXs && animals[y][x+1] != null)		{			count++;			east = new Position(x+1, y);		}		if(count>0)		{			int index = 0;			listOfNonEmpties = new Position[count];			if(north != null)			{				listOfNonEmpties[index] = north;				index++;			}			if(south != null)			{				listOfNonEmpties[index] = south;				index++;			}			if(west != null)			{				listOfNonEmpties[index] = west;				index++;			}			if(east != null)			{				listOfNonEmpties[index] = east;				index++;			}			if(northWest != null)			{				listOfNonEmpties[index] = northWest;				index++;			}			if(northEast != null)			{				listOfNonEmpties[index] = northEast;				index++;			}			if(southWest != null)			{				listOfNonEmpties[index] = southWest;				index++;			}			if(southEast != null)			{				listOfNonEmpties[index] = southEast;				index++;			}		}		else			listOfNonEmpties = new Position[0];		return listOfNonEmpties;				}			/**	*	Returns the number of columns 	*	of the cage.	*	@return maximum X value of the cage	*/	public int getMax_X()	{		return numXs;	}		/**	*	Returns the number of rows	*	of the cage.	*	@return maximum Y value of the cage	*/	public int getMax_Y()	{		return numYs;	}			/**	*	Returns the number of Animals in the Cage.	*	@return number of Animals in the cage	*/	public int getNumAnimals()	{		return numAnimals;	}			/**	*	Returns an array of all of the Animals in the cage.	*	@return an array of all animals in the cage	*/	public Animal[] allAnimals()	{		Animal[] finalList = new Animal[1];		ArrayList list = new ArrayList();		// This method uses a construction called an ArrayList 		// which you may not have seen previously.  Do not		// worry about how ArrayLists work.  Just know that in 		// the end the method will return an array of Animals.				for(int y=0; y<numYs; y++)		{			for(int x=0; x<numXs; x++)			{				if(animals[y][x] != null)				{					if(animals[y][x].isDead())						animals[y][x] = null;					else						list.add(animals[y][x]);				}			}		}		finalList = new Animal[list.size()];		for (int n=0; n<list.size(); n++)		{			finalList[n] = (Animal)(list.get(n));		}		//numAnimals = list.size();		return finalList;	}}	